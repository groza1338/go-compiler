package main

import "fmt"
import (
	"os"
	"strings"    // строковый литерал в конце строки → ;
)

var (
	a = 1          // идентификатор → ;
	b = 2.5        // float → ;
)

func f(x int) int {
	y := x +
		a            // идентификатор на предыдущей строке + перенос → ; вставляться НЕ должен (строка кончалась на '+')

	z := "hi" /* многострочный
коммент с переводом строки */ // перевод внутри /* */ должен вести себя как NL → если до него был допустимый токен, вставляем ;

	for i := 0; i < 3; i++ {
		fmt.Println(i)    // ')' → ;
	}                     // '}' → ;

	switch y {
	case "hi":            // строковый литерал перед NL → ;
		fallthrough       // ключевое слово из списка → ;
	default:
		return 42 /*multi
line*/ // перевод внутри /* */ ⇒ как NL, значит 'return 42' завершилось → ; тут тоже должен появиться
}

	select {}            // '}' → ;
	defer fmt.Println("defer!") // ')' → ;
	go fmt.Println("go!")       // ')' → ;

	x := (1 +
		2)                // строка закончилась на ')' → ; (и правило (2): перед ')' ; можно опустить)

	s := `raw
string
with
newlines`              // закрывающая '`' → ;

	fmt.
		Println(s)       // строка с '.' → ; НЕ вставляем; перенос через точку допустим

	// Проверим ']' и '}' и запятую на хвосте
	sl := []int{
		1,
		2,               // запятая в конце — не должна включать SEMI_ON
	}                    // '}' → ;

	m := map[int]int{
		1: 2,
	}                    // '}' → ;
	_ = m[1]             // ']' → ;

	a++                  // '++' → ;
	b--                  // '--' → ;

	if a > 0 &&          // строка кончается на '&&' → ; НЕ вставляем
	   b > 0 {
		a = a + 1        // идентификатор/число в конце → ;
	}

	// Несколько «пустых» строк подряд: ; не должно плодиться без причины


	fmt.Println("done")  // ')' → ;
	return 0             // 'return' → ;
}

func main() {
	f(5)                  // ')' → ;
}
