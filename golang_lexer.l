%option never-interactive
%option yylineno
%option noyywrap

/* Однострочный комментарий */
%x SCOMM

/* Многострочный комментарий */
%x MCOMM

/* Rune lit */
%x RUNE_LIT

/* Raw string */
%x RAW_STR

/* Interpreted string */
%x INTER_STR

/* Macros */
IDENTIFIER          [A-Za-z_][A-Za-z_0-9]*
WHITE_SPACES_NO_NL        [ \t\f\v]+
NL                        (\r\n|\n)

DEC_DIG             [0-9]
DEC_DIGS            {DEC_DIG}(_?{DEC_DIG})*
DEC_LIT             0|[1-9](_?{DEC_DIGS})?

OCT_DIG             [0-7]
OCT_DIGS            {OCT_DIG}(_?{OCT_DIG})*
OCT_LIT             0[oO]?_?{OCT_DIGS}

DEC_EXP             [eE][+-]?{DEC_DIGS}
DEC_FLOAT_LIT       {DEC_DIGS}\.{DEC_DIGS}?{DEC_EXP}?|{DEC_DIGS}{DEC_EXP}|\.{DEC_DIGS}{DEC_EXP}?

HEX_DIG             [0-9A-Fa-f]
HEX_DIGS            {HEX_DIG}(_?{HEX_DIG})*
HEX_LIT             0[xX]_?{HEX_DIGS}

ESC_CHAR            \\[abfnrtv\\'"]
BIG_U_VAL           \\U{HEX_DIG}{8}
LITTLE_U_VAL        \\u{HEX_DIG}{4}
HEX_BYTE_VAL        \\x{HEX_DIG}{2}
OCT_BYTE_VAL        \\{OCT_DIG}{3}
BYTE_VAL            {OCT_BYTE_VAL}|{HEX_BYTE_VAL}
UNICODE_VAL         {LITTLE_U_VAL}|{BIG_U_VAL}|{ESC_CHAR}
RUNE_LIT_BODY       ({UNICODE_VAL}|{BYTE_VAL})

INTER_STR_LIT_BODY  ({UNICODE_VAL}|{BYTE_VAL})*

%{
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <iostream>
#include <cstring>
#include <string>
#include <algorithm>
#include <cerrno>
using std::cout;

#define MAX_STRING_LENGTH 2048

void str_add_char(char *dest_str, unsigned char c);
void str_add_chars(char *dest_str, const char *src_str, size_t len);
void str_reset(char *str);
void comm_reset(char *str, int *start_line);
void from_unicode_to_utf8(char *dest_str, char *unicode_str);
void hex_escape(char *dest_str, const char *hex);
void octal_escape(char *dest_str, const char *oct);
std::string strip_underscores(const char* y);
unsigned long long parse_u64(const char* p, int base);
void set_semi_on(int *flag);
void set_semi_off(int *flag);

%}

%%

%{
char comment_buf[MAX_STRING_LENGTH];
int comment_start_line = -1;
char str_buf[MAX_STRING_LENGTH];
int can_insert_semi = 0;
%}

"break"                 {cout << "Keyword: " << yytext << '\n'; set_semi_on(&can_insert_semi);}
"case"                  {cout << "Keyword: " << yytext << '\n'; set_semi_off(&can_insert_semi);}
"chan"                  {cout << "Keyword: " << yytext << '\n'; set_semi_off(&can_insert_semi);}
"const"                 {cout << "Keyword: " << yytext << '\n'; set_semi_off(&can_insert_semi);}
"continue"              {cout << "Keyword: " << yytext << '\n'; set_semi_on(&can_insert_semi);}
"default"               {cout << "Keyword: " << yytext << '\n'; set_semi_off(&can_insert_semi);}
"defer"                 {cout << "Keyword: " << yytext << '\n'; set_semi_off(&can_insert_semi);}
"else"                  {cout << "Keyword: " << yytext << '\n'; set_semi_off(&can_insert_semi);}
"fallthrough"           {cout << "Keyword: " << yytext << '\n'; set_semi_on(&can_insert_semi);}
"for"                   {cout << "Keyword: " << yytext << '\n'; set_semi_off(&can_insert_semi); }
"func"                  {cout << "Keyword: " << yytext << '\n'; set_semi_off(&can_insert_semi); }
"go"                    {cout << "Keyword: " << yytext << '\n'; set_semi_off(&can_insert_semi); }
"goto"                  {cout << "Keyword: " << yytext << '\n'; set_semi_off(&can_insert_semi); }
"if"                    {cout << "Keyword: " << yytext << '\n'; set_semi_off(&can_insert_semi);}
"import"                {cout << "Keyword: " << yytext << '\n'; set_semi_off(&can_insert_semi);}
"interface"             {cout << "Keyword: " << yytext << '\n'; set_semi_off(&can_insert_semi);}
"map"                   {cout << "Keyword: " << yytext << '\n'; set_semi_off(&can_insert_semi);}
"package"               {cout << "Keyword: " << yytext << '\n'; set_semi_off(&can_insert_semi);}
"range"                 {cout << "Keyword: " << yytext << '\n'; set_semi_off(&can_insert_semi);}
"return"                {cout << "Keyword: " << yytext << '\n'; set_semi_on(&can_insert_semi);}
"select"                {cout << "Keyword: " << yytext << '\n'; set_semi_off(&can_insert_semi);}
"struct"                {cout << "Keyword: " << yytext << '\n'; set_semi_off(&can_insert_semi);}
"switch"                {cout << "Keyword: " << yytext << '\n'; set_semi_off(&can_insert_semi);}
"type"                  {cout << "Keyword: " << yytext << '\n'; set_semi_off(&can_insert_semi);}
"var"                   {cout << "Keyword: " << yytext << '\n'; set_semi_off(&can_insert_semi);}

{IDENTIFIER}            { cout << "Identifier: " << yytext << '\n'; set_semi_on(&can_insert_semi);}

"<<="                   { cout << "Operator: " << yytext << '\n'; set_semi_off(&can_insert_semi);}
">>="                   { cout << "Operator: " << yytext << '\n'; set_semi_off(&can_insert_semi);}
"&^="                   { cout << "Operator: " << yytext << '\n'; set_semi_off(&can_insert_semi);}

"..."                   { cout << "Varargs: " << yytext << '\n'; set_semi_off(&can_insert_semi);}


"<<"                    { cout << "Operator: " << yytext << " (shl)\n"; set_semi_off(&can_insert_semi);}
">>"                    { cout << "Operator: " << yytext << " (shr)\n"; set_semi_off(&can_insert_semi);}
"&^"                    { cout << "Operator: " << yytext << '\n'; set_semi_off(&can_insert_semi);}
"&="                    { cout << "Operator: " << yytext << '\n'; set_semi_off(&can_insert_semi);}
"|="                    { cout << "Operator: " << yytext << '\n'; set_semi_off(&can_insert_semi);}
"^="                    { cout << "Operator: " << yytext << '\n'; set_semi_off(&can_insert_semi);}
"&&"                    { cout << "Operator: " << yytext << '\n'; set_semi_off(&can_insert_semi);}
"||"                    { cout << "Operator: " << yytext << '\n'; set_semi_off(&can_insert_semi);}
"<-"                    { cout << "Operator: " << yytext << '\n'; set_semi_off(&can_insert_semi);}
"++"                    { cout << "Operator: " << yytext << '\n'; set_semi_on(&can_insert_semi);}
"--"                    { cout << "Operator: " << yytext << '\n'; set_semi_on(&can_insert_semi);}
"=="                    { cout << "Operator: " << yytext << '\n'; set_semi_off(&can_insert_semi);}

"+="                    { cout << "Operator: " << yytext << '\n'; set_semi_off(&can_insert_semi);}
"-="                    { cout << "Operator: " << yytext << '\n'; set_semi_off(&can_insert_semi);}
"*="                    { cout << "Operator: " << yytext << '\n'; set_semi_off(&can_insert_semi);}
"/="                    { cout << "Operator: " << yytext << '\n'; set_semi_off(&can_insert_semi);}
"%="                    { cout << "Operator: " << yytext << '\n'; set_semi_off(&can_insert_semi);}
"!="                    { cout << "Operator: " << yytext << '\n'; set_semi_off(&can_insert_semi);}
">="                    { cout << "Operator: " << yytext << '\n'; set_semi_off(&can_insert_semi);}
"<="                    { cout << "Operator: " << yytext << '\n'; set_semi_off(&can_insert_semi);}
":="                    { cout << "Operator: " << yytext << '\n'; set_semi_off(&can_insert_semi);}

"+"                     { cout << "Operator: " << yytext << '\n'; set_semi_off(&can_insert_semi);}
"-"                     { cout << "Operator: " << yytext << '\n'; set_semi_off(&can_insert_semi);}
"*"                     { cout << "Operator: " << yytext << '\n'; set_semi_off(&can_insert_semi);}
"/"                     { cout << "Operator: " << yytext << '\n'; set_semi_off(&can_insert_semi);}
"%"                     { cout << "Operator: " << yytext << '\n'; set_semi_off(&can_insert_semi);}
"&"                     { cout << "Operator: " << yytext << '\n'; set_semi_off(&can_insert_semi);}
"|"                     { cout << "Operator: " << yytext << '\n'; set_semi_off(&can_insert_semi);}
"^"                     { cout << "Operator: " << yytext << '\n'; set_semi_off(&can_insert_semi);}
"<"                     { cout << "Operator: " << yytext << '\n'; set_semi_off(&can_insert_semi);}
">"                     { cout << "Operator: " << yytext << '\n'; set_semi_off(&can_insert_semi);}
"="                     { cout << "Operator: " << yytext << '\n'; set_semi_off(&can_insert_semi);}
"!"                     { cout << "Operator: " << yytext << '\n'; set_semi_off(&can_insert_semi);}
"~"                     { cout << "Operator: " << yytext << '\n'; set_semi_off(&can_insert_semi);}
"."                     { cout << "Operator: " << yytext << '\n'; set_semi_off(&can_insert_semi);}
","                     { cout << "Operator: " << yytext << '\n'; set_semi_off(&can_insert_semi);}
";"                     { cout << "Operator: " << yytext << '\n'; set_semi_off(&can_insert_semi);}
":"                     { cout << "Operator: " << yytext << '\n'; set_semi_off(&can_insert_semi);}


"("                     { cout << "OParen: "  << yytext << '\n'; set_semi_off(&can_insert_semi);}
")"                     { cout << "CParen: "  << yytext << '\n'; set_semi_on(&can_insert_semi);}
"["                     { cout << "OBracket: "<< yytext << '\n'; set_semi_off(&can_insert_semi);}
"]"                     { cout << "CBracket: "<< yytext << '\n'; set_semi_on(&can_insert_semi);}
"{"                     { cout << "OBrace: "  << yytext << '\n'; set_semi_off(&can_insert_semi);}
"}"                     { cout << "CBrace: "  << yytext << '\n'; set_semi_on(&can_insert_semi);}

{DEC_LIT} {
    std::string s = strip_underscores(yytext);
    unsigned long long v = parse_u64(s.c_str(), 10);
    cout << "Decimal integer: " << v << '\n'; set_semi_on(&can_insert_semi);
}
{OCT_LIT} {
    std::string s = strip_underscores(yytext);
    const char* p = s.c_str();
    if (s.size() >= 2 && (s[1]=='o' || s[1]=='O'))
        p += 2;
    unsigned long long v = parse_u64(p, 8);
    cout << "Octal integer: " << v << '\n'; set_semi_on(&can_insert_semi);
}
{HEX_LIT} {
    std::string s = strip_underscores(yytext);
    const char* p = s.c_str() + 2;
    unsigned long long v = parse_u64(p, 16);
    cout << "Hexadecimal integer: " << v << '\n'; set_semi_on(&can_insert_semi);
}
{DEC_FLOAT_LIT} {
    std::string s = strip_underscores(yytext);
    double d = std::stod(s);
    cout << "Decimal float: " << d << '\n'; set_semi_on(&can_insert_semi);
}

"//"                                    { BEGIN(SCOMM); }
<SCOMM>[^\r\n]*                         { cout << "Single-line comment: " << yytext << '\n'; BEGIN(INITIAL); }
<SCOMM><<EOF>>                          { BEGIN(INITIAL); }

"/*"                                    { comment_start_line = yylineno; BEGIN(MCOMM); }
<MCOMM>{NL} {
    if (can_insert_semi) {
        cout << "Semicolon: ; (inserted)\n";
        set_semi_off(&can_insert_semi);
    }
    str_add_char(comment_buf, '\n');
}
<MCOMM>[^*\r\n]*                        { str_add_chars(comment_buf, yytext, yyleng); }
<MCOMM>"*"+[^*/\r\n]*                   { str_add_chars(comment_buf, yytext, yyleng); }
<MCOMM>"*"+"/"                          { cout << "Multi-line comment: " << comment_buf << '\n'; comm_reset(comment_buf, &comment_start_line); BEGIN(INITIAL); }
<MCOMM><<EOF>>                          { cout << "ERROR: unterminated multiline comment (opened at line " << comment_start_line << ")\n"; comm_reset(comment_buf, &comment_start_line); BEGIN(INITIAL); }

\"                                      { BEGIN(INTER_STR); }
\'							            { BEGIN(RUNE_LIT); }

<INTER_STR>[^\\\"\n]+       			{ str_add_chars(str_buf, yytext, yyleng); }
<RUNE_LIT>[^\\\'\n]+       				{ str_add_chars(str_buf, yytext, yyleng); }
<INTER_STR,RUNE_LIT>\\a              	{ str_add_char(str_buf, '\a'); }
<INTER_STR,RUNE_LIT>\\b              	{ str_add_char(str_buf, '\b'); }
<INTER_STR,RUNE_LIT>\\f              	{ str_add_char(str_buf, '\f'); }
<INTER_STR,RUNE_LIT>\\n              	{ str_add_char(str_buf, '\n'); }
<INTER_STR,RUNE_LIT>\\r              	{ str_add_char(str_buf, '\r'); }
<INTER_STR,RUNE_LIT>\\t              	{ str_add_char(str_buf, '\t'); }
<INTER_STR,RUNE_LIT>\\v                 { str_add_char(str_buf, '\v'); }
<INTER_STR,RUNE_LIT>\\\\                { str_add_char(str_buf, '\\'); }
<INTER_STR,RUNE_LIT>\\\"                { str_add_char(str_buf, '"'); }
<INTER_STR,RUNE_LIT>\\\'                { str_add_char(str_buf, '\''); }
<INTER_STR,RUNE_LIT>{OCT_BYTE_VAL}      { octal_escape(str_buf, yytext + 1); }
<INTER_STR,RUNE_LIT>{HEX_BYTE_VAL}      { hex_escape(str_buf, yytext + 2); }
<INTER_STR,RUNE_LIT>{LITTLE_U_VAL}      { from_unicode_to_utf8(str_buf, yytext + 2); }
<INTER_STR,RUNE_LIT>{BIG_U_VAL}         { from_unicode_to_utf8(str_buf, yytext + 2); }
<INTER_STR,RUNE_LIT>\n                  { cout << "ERROR: newline in interpreted string literal\n"; str_reset(str_buf); BEGIN(INITIAL); }
<INTER_STR,RUNE_LIT><<EOF>>             { cout << "ERROR: unterminated string (\") before EOF\n"; BEGIN(INITIAL); }

<INTER_STR>\"                           { cout << "Interpreted string: " << str_buf << '\n'; str_reset(str_buf); set_semi_on(&can_insert_semi); BEGIN(INITIAL); }
<RUNE_LIT>\' {
	if (strlen(str_buf) <= 1) { 
		cout << "Rune literal: " << str_buf << '\n'; set_semi_on(&can_insert_semi);
	} else {
		cout << "ERROR: more then one char in rune literal: " << str_buf << "\n";
	} 
	str_reset(str_buf); 
	BEGIN(INITIAL); 
}


`                       { BEGIN(RAW_STR); }
<RAW_STR>[^`\r]+        { str_add_chars(str_buf, yytext, yyleng); }
<RAW_STR>\r             { ; }
<RAW_STR>`              { cout << "Raw string: " << str_buf << '\n'; str_reset(str_buf); set_semi_on(&can_insert_semi); BEGIN(INITIAL); }
<RAW_STR><<EOF>>        { cout << "ERROR: unterminated string (`) before EOF\n"; BEGIN(INITIAL); }

{NL}                    { if (can_insert_semi) { cout << "Semicolon: ; (inserted)\n"; can_insert_semi = 0; } }
{WHITE_SPACES_NO_NL}    { ; }

<<EOF>> {
    if (can_insert_semi) {
        cout << "Semicolon: ; (inserted before EOF)\n";
    }
    return 0;
}


%%
void str_add_char(char *dest_str, unsigned char c) {
	int dest_len = strlen(dest_str); 
    if (dest_len < MAX_STRING_LENGTH - 1) {
        strcat(dest_str, &с);
    }
}

void str_add_chars(char *dest_str, const char *src_str, size_t len) {
	int dest_len = strlen(dest_str);
    if (dest_len + len >= MAX_STRING_LENGTH) {
		len = MAX_STRING_LENGTH - dest_len - 1;
    }
	strncat(dest_str, src_str, len);
}

void str_reset(char *str) {
    *str = '\0';
}

void comm_reset(char *str, int *start_line) {
    str_reset(str);
    *start_line = -1;
}

void from_unicode_to_utf8(char *dest_str, char *unicode_str) {
    int code_point = strtol(unicode_str, NULL, 16);
    if (code_point <= 0x7F) {
        str_add_char(dest_str, (char)code_point);
    } else if (code_point <= 0x7FF) {
        str_add_char(dest_str, 0xC0 | ((code_point >> 6) & 0x1F));
        str_add_char(dest_str, 0x80 | (code_point & 0x3F));
    } else if (code_point <= 0xFFFF) {
        str_add_char(dest_str, 0xE0 | ((code_point >> 12) & 0x0F));
        str_add_char(dest_str, 0x80 | ((code_point >> 6) & 0x3F));
        str_add_char(dest_str, 0x80 | (code_point & 0x3F));
    } else if (code_point <= 0x10FFFF) {
        str_add_char(dest_str, 0xF0 | ((code_point >> 18) & 0x07));
        str_add_char(dest_str, 0x80 | ((code_point >> 12) & 0x3F));
        str_add_char(dest_str, 0x80 | ((code_point >> 6) & 0x3F));
        str_add_char(dest_str, 0x80 | (code_point & 0x3F));
    }
}

void hex_escape(char *dest_str, const char *hex) {
    int value = strtol(hex, NULL, 16);
    str_add_char(dest_str, (char)value);
}

void octal_escape(char *dest_str, const char *oct) {
    int value = strtol(oct, NULL, 8);
    str_add_char(dest_str, (char)value);
}

std::string strip_underscores(const char* y) {
    std::string s(y);
    s.erase(std::remove(s.begin(), s.end(), '_'), s.end());
    return s;
}

unsigned long long parse_u64(const char* p, int base) {
    errno = 0;
    char* end = nullptr;
    unsigned long long v = std::strtoull(p, &end, base);
    return v;
}

void set_semi_on(int *flag) {
	*flag = 1;
}

void set_semi_off(int *flag) {
	*flag = 0;
}