------------------------------------------ ключ. слово или идентификатор ------------------------------------------
%%
if {cout<<yytext<< ветвеление <<endl;}
for {cout<<yytext<<endl;}
while {cout<<yytext<<endl;}
[a-zA-Z_][a-zA-Z_0-9]* {cout<<yytext<<endl;}

------------------------------------------ многострочный комментарий на C через состояния ------------------------------------------

%x COMMENT

%% 
\/\* {BEGIN(COMMENT);}
<COMMENT> [^*]+
<COMMENT> \*+[^\/\*]+	/*лгцапашгцп ***/  /* ц ацацуцуацу*/
<COMMENT> \*+\/ {BEGIN(INITIAL);}

------------------------------------------ строковые константы ------------------------------------------

%%

%x STRING_CONST

%%
%{
	char buffer[1024];
%}
\" {BEGIN(STRING_CONST); buffer[0]=0;} <- Вход
<STRING_CONST> [^\"\'\n\\]+ {strcat(buffer,yytext);}
<STRING_CONST> \\n {strcat(buffer,"\n");}
<STRING_CONST> \\t {strcat(buffer,"\t");}
<STRING_CONST> \\\" {strcat(buffer,"\"");}
<STRING_CONST> \\\\ {strcat(buffer,"\\");}
<STRING_CONST> \\[0-7]{1-3} {strcat(buffer,<<станд. функц. для перевода строки в char>>);}
<STRING_CONST> \n {printf("Newline char was found.\n"); BEGIN(INITIAL);}
<STRING_CONST> <<EOF>> {...; BEGIN(INITIAL);}
<STRING_CONST> \" {BEGIN(INITIAL); puts(buffer);} <- Выход


//**************************** Парсер ****************************//

!! Если роль конца stmt выполняет \n, нужно выделить для него отдельный терминал (ENDL).
!! Рассмотреть ENDL_LIST, который будет содержать множество идущих подряд ENDL. 
!! В правилах не допустимо ставить два ENDL_LIST подряд.
!! Все приоритеты работают только тогда, когда весь epxr - это один нетерминал с длинным списком

!! 4 варианта списков
!! 1 ось: пустота или хотя бы один элемент
!! 2 ось: содержит ли список разделители

!! При рекурсии используется левая рекурсия (рекурсивно вызываемый нетерминал слева от другого нетерминала).

%%
while_stmt	: WHILE '(' expr ')' stmt
			;
			
for_stmt	:	FOR '(' var_decl ';' expr ';' expr ')' stmt
			|	FOR '(' expr ';' expr ';' expr ')' stmt	
			;
		
stmt		:	while_stmt
			|	for_stmt
			|	if_stmt
			|	expr ';'
			|	RETURN expr ';'
			|	RETURN ';'
			|	'{' expr_list '}'
			|	';'
			;
		
if_stmt		:	IF '(' expr ')' stmt
			|	IF '(' expr ')' stmt ELSE stmt
			;
		
expr		:	L_INT
			|	L_STR
			|	ID
			|	'-'	expr		%prec U_MINUS
			|	expr '+' expr
			|	expr '-' expr
			|	'(' expr ')'
			|	expr '[' expr ']'
			|	expr '.' ID
			|	ID '(' e_expr_list ')'
			;
		
stmt_list	:	stmt_list stmt		
			|	stmt
			;
			
e_stmt_list	:	stmt_list
			|
			;
			
expr_list	:	expr_list ',' expr
			|	expr
			;
			
e_expr_list	:	expr_list
			|	
			;
			
type		:	INTKW
			|	ID
			;
			
decl		:	type ID ';'
			|	type ID '(' param_list ')' ';'
			|	VOID ID '(' param_list ')' ';'
			;
			
			Это является LR(2) грамматикой и образует конфликт
%%

/****************************** Женитьба парсера и лексера ********************************/

----------------------------------------------- .l ---------------------------------------------

%union{
  StmtNode *StmtField;
  ...
}

%type<StmtField> if_stmt stmt for_stmt



%%
if_stmt		: 	IF '(' expr ')' stmt {$$=StmtNode::createIfStmt($3, $5, NULL);}
			| 	IF '(' expr ')' stmt ELSE stmt {$$=StmtNode::createIfStmt($3, $5, $7);}
			;

stmt_list	:	stmt_list stmt	{$$ = StmtNode::addStmtToList($1, $2);}
			|	stmt			{$$ = StmtNode::createStmtList($1);}
			;



---------------------------------------------- .h ----------------------------------------------
enum StmtType{ ifStmt, forStmt, exprStmt, block};

class AstNode {
  protected:
    static uint maxId;
    uint id;
  public:
    AstNode(){id = ++maxId;}
};

class StmtNode: public AstNode {
  protected:
    StmtType type;
    ExprNode *cond;
    StmtNode *thenBranch, *elseBranch;
    ExprNode *expr;
    list<StmtNode*> blockStmts;

  public:
    static StmtNode* createIfStmt(ExprNode *cond, StmtNode *thenBranch, StmtNode *elseBranch);
    static StmtNode* createStmtList(StmtNode* stmt);
    static StmtNode* addStmtToList(StmtNode* list, StmtNode* stmt);
    StmtNode(): AstNode(){};
};
	


---------------------------------------------- .cpp ----------------------------------------------


static StmtNode* StmtNode::createIfStmt(ExprNode *cond, StmtNode *thenBranch, StmtNode *elseBranch){
	StmtNode *node = new StmtNode();
	node->type = ifStmt;
	node->cond = cond;
	node->thenBranch = thenBranch;
	node->elseBranch = elseBranch;
	return node; 
}

static StmtNode* StmtNode::createStmtList(StmtNode* stmt) {
	StmtNode* node = new StmtNode();
	node->type = block;
	node->blockStmts.push_back(stmt);
	return node;
}

static StmtNode* StmtNode::addStmtToList(StmtNode* list, StmtNode* stmt) {
	list->blockStmts.push_back(stmt);
	return list;
}

static uint AstNode::maxId = 0;
